let scanint x = Scanf.sscanf x "%d " (fun y -> y);;
let transform x = Array.of_list (List.map (scanint) (String.split_on_char ',' x));;


let read_input_data path =
  let ic = open_in path in
  let stri  = input_line ic in
  close_in_noerr ic;
  transform stri
;;


let decompose data i base =
  if data.(i) == 99
  then (99, 0, 0, 0)
  else (
    let (op, inter) = (data.(i) mod 100, data.(i) / 100) in
    if (op <= 2) || ((op > 4) && (op < 9))
    then (
      let ga = inter mod 10
      and gb = (inter / 10) mod 10
      and gc = (inter / 100) mod 10
      in

      let a = if ga == 0
              then data.(data.(i+1))
              else if ga == 2 then data.(data.(i+1) + base)
              else data.(i+1)
      and b = if gb == 0
              then data.(data.(i+2))
              else if gb == 2 then data.(data.(i+2) + base)
              else data.(i+2)
      and c = if gc == 0  (*No 1 normaly*)
              then data.(i+3)
              else data.(i+3) + base in
      (op, a, b, c)
      )
      else if (op == 9)
      then (
        let res = if inter mod 10 == 0 then data.(data.(i+1))
                  else if inter mod 10 == 1 then data.(i+1)
                  else data.(data.(i+1) + base) in
        (9, res, 0, 0)
        )
      else if op == 4
      then (
        let res = if inter mod 10 == 0 then data.(data.(i+1))
                  else if inter mod 10 == 1 then data.(i+1)
                  else data.(data.(i+1) + base) in
        (4, res, 0, 0)
        )
      else if (op == 3)
      then (
        let res = if inter mod 10 == 0 then data.(i+1)
                  else if inter mod 10 == 1 then i+1
                  else data.(i+1) + base in
        (op, res, 0, 0))
      else (
        (op, data.(i+1), 0, 0)
        )
    )
;;


type ptx = {x:int; y:int};;

let solve data_in l pt =
  let data = Array.make l 0 in
  Array.iteri (fun i x -> data.(i) <- x) data_in;

  let point = ref false in
  let result = ref 0 in

  let process_code op a b c i base =
  if op == 1
  then (data.(c) <- a + b; (i + 4, base))
  else if op == 2
  then (data.(c) <- a * b; (i + 4, base))
  else if op == 3
  then (
    let inp = if !point then pt.y else pt.x in
    point := true;
    (*let inp = read_int () in*)
    data.(a) <- inp;
    (i + 2, base))
  else if op == 4
  then (
    result := a;
    (i + 2, base))
  else if op == 5
  then (let res = if a != 0 then b else i + 3 in
    (res, base))
  else if op == 6
  then (let res = if a == 0 then b else i+3
    in (res, base))
  else if op == 7
  then (data.(c) <- if a < b then  1 else 0;
    (i+4, base))
  else if op == 8
  then (data.(c) <- if a == b then  1 else 0;
    (i+4, base))
  else if op == 9
  then (i + 2, base + a)
  else if op == 99
  then (
    (i + l*2, base))
  else (
    (i + l*2, base))
  in

  let rec nest i base =
    if i >= l then !result
    else (
      let (op, a, b, c) = decompose data i base in
      let (ip, base_n) = process_code op a b c i base in
      nest ip base_n
      )
    in nest 0 0
;;


let data = read_input_data "input_19";;
let k = 50 ;;
let mat = Array.init k (fun j ->
  Array.init k (fun i -> solve data 10000 {x=i; y=j}));;


let print_mat mat =
  Array.iter (fun row ->
    Array.iter (Printf.printf "%d") row;
    print_newline ()
    ) mat;;

let count_mat mat =
  Array.fold_left (fun mem row ->
    mem + (Array.fold_left (+) 0 row)
    ) 0 mat;;


(*Part 2*)

let search_mat px v0 v1 k =
  let rec nest mem ki x =
  if ki == k
  then mem
  else (
    let r0 = solve data 10000 {x=x; y=ki}
    and r1 = solve data 10000 {x=x+1; y=ki} in
    if (r0 == v0) && (r1 == v1)
    then (
      Printf.printf "%d: %d\n" ki x;
      nest ({x=x; y=ki}::mem) (ki+1) x)
    else nest mem ki (x+1)
    ) in nest [] px.x px.y
;;

let l = 1300;;
let pup = search_mat {x=10; y=3} 1 0 l;;
let pdo = search_mat {x=10; y=3} 0 1 l;;
let pdo_b = List.map (fun p -> {x=p.x+1; y=p.y}) pdo;;

let search_best_point sq pup pdo l =
  let mem_up = Array.make l 0
  and mem_do = Array.make l 0 in
  List.iter (fun p -> mem_up.(p.y) <- p.x) pup;
  List.iter (fun p -> mem_do.(p.y) <- p.x) pdo;

  let rec nest yi =
  let dx = mem_up.(yi) - mem_do.(yi+sq-1) + 1 in
  Printf.printf "%d:\t %d\n" yi dx;
  if dx >= sq
  then yi
  else nest (yi+1)
  in
  let yy = nest 0 in
  (yy, mem_do.(yy+sq-1), mem_do.(yy+sq-1)*10000+ yy)
;;

search_best_point 3 pup pdo_b l;;




















10000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000
00001000000000000000000000000000000000000000000000
00000100000000000000000000000000000000000000000000
00000010000000000000000000000000000000000000000000
00000001000000000000000000000000000000000000000000
00000001100000000000000000000000000000000000000000
00000000110000000000000000000000000000000000000000
00000000011000000000000000000000000000000000000000
00000000001100000000000000000000000000000000000000
00000000001110000000000000000000000000000000000000
00000000000111000000000000000000000000000000000000
00000000000011100000000000000000000000000000000000
00000000000001110000000000000000000000000000000000
00000000000001110000000000000000000000000000000000
00000000000000111000000000000000000000000000000000
00000000000000011100000000000000000000000000000000
00000000000000001110000000000000000000000000000000
00000000000000001111000000000000000000000000000000
00000000000000000111100000000000000000000000000000
00000000000000000011110000000000000000000000000000
00000000000000000001111000000000000000000000000000
00000000000000000001111100000000000000000000000000
00000000000000000000111110000000000000000000000000
00000000000000000000011111000000000000000000000000
00000000000000000000001111100000000000000000000000
00000000000000000000001111110000000000000000000000
00000000000000000000000111111000000000000000000000
00000000000000000000000011111100000000000000000000
00000000000000000000000001111110000000000000000000
00000000000000000000000001111111000000000000000000
00000000000000000000000000111111000000000000000000
00000000000000000000000000011111100000000000000000
00000000000000000000000000001111110000000000000000
00000000000000000000000000001111111000000000000000
00000000000000000000000000000111111100000000000000
00000000000000000000000000000011111110000000000000
00000000000000000000000000000001111111000000000000
00000000000000000000000000000001111111100000000000
00000000000000000000000000000000111111110000000000
00000000000000000000000000000000011111111000000000
00000000000000000000000000000000001111111100000000
00000000000000000000000000000000000111111110000000
00000000000000000000000000000000000111111111000000
00000000000000000000000000000000000011111111100000
00000000000000000000000000000000000001111111110000
00000000000000000000000000000000000000111111111000



10000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000
00000100000000000000000000000000000000000000000000
00000010000000000000000000000000000000000000000000
00000001000000000000000000000000000000000000000000
00000000110000000000000000000000000000000000000000
00000000011000000000000000000000000000000000000000
00000000001100000000000000000000000000000000000000
00000000000111000000000000000000000000000000000000
00000000000011100000000000000000000000000000000000
00000000000001110000000000000000000000000000000000
00000000000000111100000000000000000000000000000000
00000000000000011110000000000000000000000000000000
00000000000000001111000000000000000000000000000000
00000000000000000011110000000000000000000000000000
00000000000000000001111000000000000000000000000000
00000000000000000000111100000000000000000000000000
00000000000000000000011111000000000000000000000000
00000000000000000000001111100000000000000000000000
00000000000000000000000111110000000000000000000000
00000000000000000000000011111100000000000000000000
00000000000000000000000001111110000000000000000000
00000000000000000000000000111111000000000000000000
00000000000000000000000000011111110000000000000000
00000000000000000000000000001111111000000000000000
00000000000000000000000000000111111100000000000000
00000000000000000000000000000011111111000000000000
00000000000000000000000000000001111111100000000000
00000000000000000000000000000000111111110000000000
00000000000000000000000000000000011111111100000000
00000000000000000000000000000000000111111110000000
00000000000000000000000000000000000011111111000000
00000000000000000000000000000000000001111111100000
00000000000000000000000000000000000000111111111000
00000000000000000000000000000000000000011111111100
00000000000000000000000000000000000000001111111110
00000000000000000000000000000000000000000111111111
00000000000000000000000000000000000000000011111111
00000000000000000000000000000000000000000001111111
00000000000000000000000000000000000000000000111111
00000000000000000000000000000000000000000000011111
00000000000000000000000000000000000000000000001111
00000000000000000000000000000000000000000000000111
00000000000000000000000000000000000000000000000011
00000000000000000000000000000000000000000000000001
00000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000




(*7010851 too low*)
7900946
(*7910947 too high*)
(*7950951 too high*)


#.......................................
.#......................................
..##....................................
...###..................................
....###.................................
.....####...............................
......#####.............................
......######............................
.......#######..........................
........########........................
.........#########......................
..........#########.....................
...........##########...................
...........############.................
............############................
.............#############..............
..............##############............
...............###############..........
................###############.........
................#################.......
.................########OOOOOOOOOO.....
..................#######OOOOOOOOOO#....
...................######OOOOOOOOOO###..
....................#####OOOOOOOOOO#####
.....................####OOOOOOOOOO#####
.....................####OOOOOOOOOO#####
......................###OOOOOOOOOO#####
.......................##OOOOOOOOOO#####
........................#OOOOOOOOOO#####
.........................OOOOOOOOOO#####
..........................##############
..........................##############
...........................#############
............................############
.............................###########
